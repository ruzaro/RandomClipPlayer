<html lang="en">

<body>

<script src="common.js"></script>

<script>
    const FILTER_FILE_PATH = 'filter.txt'

    class AuthFetch {
        constructor(clientId, clientSecret, broadcasterName) {
            this.clientId = clientId;
            this.clientSecret = clientSecret;
            this.broadcasterName = broadcasterName;
        }

        static async create(globalConfig) {
            let clientId = globalConfig["CLIENT_ID"];
            if (clientId === null) {
                throw new Error("CLIENT_ID key missing in " + CONFIG_FILE_PATH);
            }

            let clientSecret = globalConfig["CLIENT_SECRET"];
            if (clientSecret === null) {
                throw new Error("CLIENT_SECRET key missing in " + CONFIG_FILE_PATH);
            }

            let broadcasterName = globalConfig["BROADCASTER_NAME"];
            if (broadcasterName === null) {
                throw new Error("BROADCASTER_NAME key missing in " + CONFIG_FILE_PATH);
            }

            return new AuthFetch(clientId, clientSecret, broadcasterName);
        }

        async prepareOAuth() {
            this.oAuth = await this.prepareCredentials();
            this.broadcasterId = await this.prepareBroadcasterId();
        }

        async prepareCredentials() {
            const response = await fetch(`https://id.twitch.tv/oauth2/token?client_id=${this.clientId}&client_secret=${this.clientSecret}&grant_type=client_credentials`, {
                method: "POST"
            });
            return await response.json();
        }

        async prepareBroadcasterId() {
            const response = await this.fetch(`https://api.twitch.tv/helix/users?login=${this.broadcasterName}`);
            return (await response.json()).data[0].id;
        }

        async fetch(url, options) {
            options = options || {};
            options.headers = options.headers || {};

            options.headers["Client-ID"] = this.clientId;
            options.headers["Authorization"] = `Bearer ${this.oAuth.access_token}`;

            return await fetch(url, options);
        }
    }

    const Mode = {
        Top: 'Top',
        Random: 'Random'
    };

    class ClipsHandlerConfig {
        constructor(topOrRandom, maxClips) {
            this.maxClips = maxClips;
            this.topOrRandom = topOrRandom;
            this.wordsToFilter = []
        }

        static async create(globalConfig) {
            let topOrRandom = globalConfig["TOP_OR_RANDOM"];

            // TOP_OR_RANDOM can be either Mode.Top to prioritise top clips or Mode.Random to get random clips out of your top 1000
            // note that Mode.Random clip mode requires a tiny bit of buffer time when the page is first loaded to collect a list of clips

            if (topOrRandom === "top") {
                topOrRandom = Mode.Top;
            } else {
                topOrRandom = Mode.Random;
            }

            const maxClips = parseNumber(globalConfig["MAX_CLIPS"], 1000);

            let config = new ClipsHandlerConfig(topOrRandom, maxClips);

            if (await fileExists(FILTER_FILE_PATH)){
                let text = await (await fetch(FILTER_FILE_PATH)).text();

                const lines = text.split('\n');

                for (let line of lines) {
                    config.wordsToFilter.push(line);
                }
            }

            return config;
        }
    }

    class ClipsHandler {
        constructor(authFetch, clipsHandlerConfig) {
            this.authFetch = authFetch;
            this.clipsPagination = null
            this.clipsData = []
            this.config = clipsHandlerConfig;
        }

        static async create(globalConfig) {
            let clipsHandlerConfig = await ClipsHandlerConfig.create(globalConfig);

            let authFetch = await AuthFetch.create(globalConfig);

            await authFetch.prepareOAuth();

            return new ClipsHandler(authFetch, clipsHandlerConfig);
        }

        async fetchTopClips() {
            if (this.clipsData.length !== 0) return []

            let response = await this.authFetch.fetch(`https://api.twitch.tv/helix/clips?first=100&broadcaster_id=${this.authFetch.broadcasterId}${this.clipsPagination ? `&after=${this.clipsPagination}` : ""}`);
            let body = await response.json();

            this.clipsPagination = body.pagination.cursor;

            return this.filterClips(body.data);
        }

        async fetchRandomClips() {
            if (!this.clipsPagination && this.clipsData.length > 0) return [];

            let response = await this.authFetch.fetch(`https://api.twitch.tv/helix/clips?first=100&broadcaster_id=${this.authFetch.broadcasterId}${this.clipsPagination ? `&after=${this.clipsPagination}` : ""}`);
            let body = await response.json();

            this.clipsPagination = body.pagination.cursor;

            return this.filterClips(body.data);
        }

        filterClips(clips){
            let ret = []
            let wordsToFilter = this.config.wordsToFilter;

            for (let clip of clips) {
                let title = clip.title.toLowerCase();

                let valid = true;

                for (let k = 0; k < wordsToFilter.length; ++k){
                    let wordToFilter = wordsToFilter[k];

                    if (title.includes(wordToFilter)){
                        valid = false;
                        break;
                    }
                }

                if (valid){
                    ret.push(clip);
                }
            }

            return ret;
        }

        async fetchClips() {
            if (this.clipsData.length >= this.config.maxClips) return;

            let newClips = this.config.topOrRandom === Mode.Top ? await this.fetchTopClips() : await this.fetchRandomClips()

            for (let newClip of newClips) {
                if (!this.clipsData.some(x => x.id === newClip.id)) {
                    this.clipsData.push(newClip);
                }
            }
        }

        async getNextClip() {
            if (this.clipsData.length === 0) return null

            let clipData = this.selectNextClip();

            let clipInfo = await this.getClipInfo(clipData.id);

            clipData.url = await this.getDownloadUrl(clipData.id);
            clipData.gameName = clipInfo.game.displayName;

            return clipData;
        }

        selectNextClip(){
            let clipData;

            if (this.config.topOrRandom === Mode.Top) {
                clipData = this.clipsData[0];
            } else {
                let random = Math.floor(Math.random() * Object.keys(this.clipsData).length);

                const index = Object.keys(this.clipsData)[random];

                clipData = this.clipsData[index];
            }

            this.clipsData.splice(this.clipsData.indexOf(clipData), 1);

            return clipData;
        }

        async getClipInfo(clipId) {
            const url = "https://gql.twitch.tv/gql";

            const requestBody = {
                query: `query{clip(slug:\"${clipId}\"){game{displayName}}}`,
                variables: {}
            };

            const response = await fetch(url, {
                method: "POST",
                headers: {
                    "Client-ID": "kimne78kx3ncx6brgo4mv6wki5h1ko",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });

            return (await response.json()).data.clip;
        }

        async getClipLinks(clipId) {
            const url = "https://gql.twitch.tv/gql";

            const requestBody = {
                operationName: "VideoAccessToken_Clip",
                variables: { slug: clipId },
                extensions: {
                    persistedQuery: {
                        version: 1,
                        sha256Hash: "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11"
                    }
                }
            };

            const response = await fetch(url, {
                method: "POST",
                headers: {
                    "Client-ID": "kimne78kx3ncx6brgo4mv6wki5h1ko",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });

            const data = await response.json();

            if (data.data.clip.videoQualities && data.data.clip.videoQualities.length > 0) {
                data.data.clip.videoQualities.sort((a, b) => b.frameHeight - a.frameHeight);
            }

            return data;
        }

        async getDownloadUrl(clipId) {
            const clipData = await this.getClipLinks(clipId);
            const clip = clipData.data.clip;

            if (!clip.playbackAccessToken) {
                throw new Error("Invalid Clip, deleted possibly?");
            }

            if (!clip.videoQualities || clip.videoQualities.length === 0) {
                throw new Error("Clip has no video qualities, deleted possibly?");
            }

            const qualityMatch = clip.videoQualities[0];

            const downloadUrl = qualityMatch.sourceURL;

            return `${downloadUrl}?sig=${clip.playbackAccessToken.signature}&token=${encodeURIComponent(clip.playbackAccessToken.value)}`;
        }
    }

    class Clip {
        constructor(data) {
            this.data = data;
        }
    }

    class PlayerHandler {
        constructor(globalConfig) {
            const volume = parseRange(globalConfig["VOLUME_PERCENT"], 0, 100, 50);

            {
                const player = document.getElementById("player1");

                player.load();
                player.loop = false;
                player.controls = false;
                player.volume = volume / 100;

                this.current = player;
            }
            {
                const player = document.getElementById("player2");

                player.load();
                player.loop = false;
                player.controls = false;
                player.volume = volume / 100;

                this.next = player;
            }

            this.hide(this.current);
            this.hide(this.next);
        }

        addEndedListener(func){
            this.current.addEventListener("ended", func);
            this.next.addEventListener("ended", func);
        }

        async playClip(){
            let temp = this.current;
            this.current = this.next;
            this.next = temp;

            let player = this.current;
            this.show(player);
            this.hide(this.next);

            await player.play();
        }

        prepareNextClip(clip) {
            let player = this.next;

            player.pause();
            player.src = clip.url;
        }

        show(player) {
            player.style.display = 'block';
        }

        hide(player) {
            player.style.display = 'none';
        }
    }

    class ClipPlayer{
        constructor(playerHandler, clipsHandler, channel) {
            this.next = null;
            this.playerHandler = playerHandler;
            this.clipsHandler = clipsHandler;
            this.channel = channel;
            this.playing = false;
            this.fetching = null;

            this.playerHandler.addEndedListener(async () => {
                this.playing = false;

                await this.fetching;

                this.fetching = null;

                await this.playNextClip();
            });
        }

        async playNextClip(){
            if (this.next === null){
                this.channel.postMessage("clear");
                await this.clipsHandler.fetchClips();
                this.next = await this.clipsHandler.getNextClip();
                this.playerHandler.prepareNextClip(this.next);
            }

            this.playing = true;
            this.fetching = this.fetchNextClips()
            await Promise.all([this.playClip(this.next), this.fetching]);
        }

        async playClip(clip){
            await this.playerHandler.playClip(clip)
            this.channel.postMessage(JSON.stringify(clip));
        }

        fetchNextClips() {
            return new Promise(async (resolve, reject) => {
                this.next = await this.clipsHandler.getNextClip();
                this.playerHandler.prepareNextClip(this.next);

                const maxAttempts = 10;
                let attempts = 0;
                while (attempts < maxAttempts) {
                    if (!this.playing) {
                        resolve("Success: Condition met.");
                        return;
                    }
                    await this.clipsHandler.fetchClips()
                    ++attempts;
                }

                resolve("Success: Max attempts.");
            });
        }
    }

    async function run() {
        let channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);

        let globalConfig = await readGlobalConfig();

        const player = new PlayerHandler(globalConfig)

        let clipsHandler = await ClipsHandler.create(globalConfig);

        let clipPlayer = new ClipPlayer(player, clipsHandler, channel);

        await clipPlayer.playNextClip();
    }

    window.addEventListener("load", run);
</script>
<div class="container">
    <video id="player1" style="width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: -1;"></video>
    <video id="player2" style="width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: -1;"></video>
</div>
</body>

<head>
    <style>
        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }
    </style>
    <title>Twitch Clip Player</title>
</head>

</html>